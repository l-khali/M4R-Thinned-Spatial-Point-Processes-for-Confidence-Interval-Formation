k_vals <- cbind(k_vals, rowSums(k_vals_current) / (n_sum * (n_sum - 1)))
}
K_est <- as.data.frame(Kest(data, r = r_vector, correction=c("isotropic")))["iso"]
lower_approx <- c()
upper_approx <- c()
for (radius in 1:15) {
sorted_k_vals <- sort(as.numeric(k_vals[radius,-1]))
lower <- sorted_k_vals[round((R+1)*(1-alpha/2), digits=0)]
upper <- sorted_k_vals[round((R+1)*(alpha/2), digits=0)]
lower_approx <- c(lower_approx, 2*K_est[radius,] - lower)
upper_approx <- c(upper_approx, 2*K_est[radius,] - upper)
}
return(cbind(lower_approx, upper_approx))
}
marked4 <- poisson_simulation_marked_point2(100, 250, 4, 0.05)
source("poisson_simulation_method_1.R")
library(spatstat)
marked_point_method2 <- function(data, N, alpha, R=99) {
npoints <- nrow(as.data.frame(data))
r <- t(as.data.frame(replicate(npoints,seq(0.0, 0.14, 0.01))))
weights <- edge.Ripley(data,pairdist(data))
a <- 1/N
increment <- 1/sqrt(N)
window <- owin(c(0, increment), c(0,increment))
r_vector <- seq(0.0, 0.14, 0.01)
k_vals <- data.frame(r_vector)
marks <- as.data.frame(matrix(0, ncol = 15, nrow = npoints))
datadf <- as.data.frame(data)
for (point in 1:(nrow(datadf)-1)) {
x1 <- datadf[point,1]
y1 <- datadf[point,2]
for (other_point in (point+1):(nrow(datadf))) {
x2 <- datadf[other_point,1]
y2 <- datadf[other_point,2]
for (radius_index in 1:15) {
current_radius <- seq(0.0, 0.14, 0.01)[radius_index]
if ((x1-x2)**2+(y1-y2)**2 <= current_radius**2) {
marks[point,radius_index:15] <- marks[point,radius_index:15] + rep(weights[point, other_point], each=length(radius_index:15))
marks[other_point,radius_index:15] <- marks[other_point,radius_index:15] + rep(weights[other_point, point], each=length(radius_index:15))
break
}
}
}
}
marks(data) <- marks
# assuming that confence intervals formed in the same way as subsets method
for (sim in 1:R) {
n_sum <- 0
k_vals_current <- data.frame(rep(c(0), each=15))
for (i in 1:N) {
xstart <- runif(1,0,1)
ystart <- runif(1,0,1)
xend <- xstart + 1/sqrt(N)
yend <- ystart + 1/sqrt(N)
# using modulus so that points that "wrap around" are next to each other
if (xend <= 1 & yend <= 1) {
subregion <- as.data.frame(subset(data, (xstart <= x & x < xend) & (ystart <= y & y < yend)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
} else if (xend > 1 & yend <= 1) {
subregion <- as.data.frame(subset(data, (xstart <= x | x < xend %% 1) & (ystart <= y & y < yend)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart)))
} else if (xend <= 1 & yend > 1) {
subregion <- as.data.frame(subset(data, (xstart <= x & x < xend) & (ystart <= y | y < yend %% 1)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart)))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
} else {
subregion <- as.data.frame(subset(data, (xstart <= x | x < xend %% 1) & (ystart <= y | y < yend %% 1)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
}
n <- nrow(subregion)
n_sum <- n_sum + n
subregion <- as.ppp(subregion, window)
print(paste0("marks:",marks(subregion)))
k <- colSums(marks(subregion))
print(paste0("k:",k))
k_vals_current <- cbind(k_vals, as.numeric(k))
return(k_vals_current)
}
k_vals <- cbind(k_vals, rowSums(k_vals_current) / (n_sum * (n_sum - 1)))
}
K_est <- as.data.frame(Kest(data, r = r_vector, correction=c("isotropic")))["iso"]
lower_approx <- c()
upper_approx <- c()
for (radius in 1:15) {
sorted_k_vals <- sort(as.numeric(k_vals[radius,-1]))
lower <- sorted_k_vals[round((R+1)*(1-alpha/2), digits=0)]
upper <- sorted_k_vals[round((R+1)*(alpha/2), digits=0)]
lower_approx <- c(lower_approx, 2*K_est[radius,] - lower)
upper_approx <- c(upper_approx, 2*K_est[radius,] - upper)
}
return(cbind(lower_approx, upper_approx))
}
marked4 <- poisson_simulation_marked_point2(100, 250, 4, 0.05)
source("poisson_simulation_method_1.R")
library(spatstat)
marked_point_method2 <- function(data, N, alpha, R=99) {
npoints <- nrow(as.data.frame(data))
r <- t(as.data.frame(replicate(npoints,seq(0.0, 0.14, 0.01))))
weights <- edge.Ripley(data,pairdist(data))
a <- 1/N
increment <- 1/sqrt(N)
window <- owin(c(0, increment), c(0,increment))
r_vector <- seq(0.0, 0.14, 0.01)
k_vals <- data.frame(r_vector)
marks <- as.data.frame(matrix(0, ncol = 15, nrow = npoints))
datadf <- as.data.frame(data)
for (point in 1:(nrow(datadf)-1)) {
x1 <- datadf[point,1]
y1 <- datadf[point,2]
for (other_point in (point+1):(nrow(datadf))) {
x2 <- datadf[other_point,1]
y2 <- datadf[other_point,2]
for (radius_index in 1:15) {
current_radius <- seq(0.0, 0.14, 0.01)[radius_index]
if ((x1-x2)**2+(y1-y2)**2 <= current_radius**2) {
marks[point,radius_index:15] <- marks[point,radius_index:15] + rep(weights[point, other_point], each=length(radius_index:15))
marks[other_point,radius_index:15] <- marks[other_point,radius_index:15] + rep(weights[other_point, point], each=length(radius_index:15))
break
}
}
}
}
marks(data) <- marks
# assuming that confence intervals formed in the same way as subsets method
for (sim in 1:R) {
n_sum <- 0
k_vals_current <- data.frame(rep(c(0), each=15))
for (i in 1:N) {
xstart <- runif(1,0,1)
ystart <- runif(1,0,1)
xend <- xstart + 1/sqrt(N)
yend <- ystart + 1/sqrt(N)
# using modulus so that points that "wrap around" are next to each other
if (xend <= 1 & yend <= 1) {
subregion <- as.data.frame(subset(data, (xstart <= x & x < xend) & (ystart <= y & y < yend)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
} else if (xend > 1 & yend <= 1) {
subregion <- as.data.frame(subset(data, (xstart <= x | x < xend %% 1) & (ystart <= y & y < yend)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart)))
} else if (xend <= 1 & yend > 1) {
subregion <- as.data.frame(subset(data, (xstart <= x & x < xend) & (ystart <= y | y < yend %% 1)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart)))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
} else {
subregion <- as.data.frame(subset(data, (xstart <= x | x < xend %% 1) & (ystart <= y | y < yend %% 1)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
}
n <- nrow(subregion)
n_sum <- n_sum + n
subregion <- as.ppp(subregion, window)
#print(paste0("marks:",marks(subregion)))
k <- colSums(marks(subregion))
#print(paste0("k:",k))
k_vals_current <- cbind(k_vals, as.numeric(k))
print(paste0("current",k_vals_current))
}
k_vals <- cbind(k_vals, rowSums(k_vals_current) / (n_sum * (n_sum - 1)))
}
K_est <- as.data.frame(Kest(data, r = r_vector, correction=c("isotropic")))["iso"]
lower_approx <- c()
upper_approx <- c()
for (radius in 1:15) {
sorted_k_vals <- sort(as.numeric(k_vals[radius,-1]))
lower <- sorted_k_vals[round((R+1)*(1-alpha/2), digits=0)]
upper <- sorted_k_vals[round((R+1)*(alpha/2), digits=0)]
lower_approx <- c(lower_approx, 2*K_est[radius,] - lower)
upper_approx <- c(upper_approx, 2*K_est[radius,] - upper)
}
return(cbind(lower_approx, upper_approx))
}
marked4 <- poisson_simulation_marked_point2(100, 250, 4, 0.05)
source("poisson_simulation_method_1.R")
library(spatstat)
marked_point_method2 <- function(data, N, alpha, R=99) {
npoints <- nrow(as.data.frame(data))
r <- t(as.data.frame(replicate(npoints,seq(0.0, 0.14, 0.01))))
weights <- edge.Ripley(data,pairdist(data))
a <- 1/N
increment <- 1/sqrt(N)
window <- owin(c(0, increment), c(0,increment))
r_vector <- seq(0.0, 0.14, 0.01)
k_vals <- data.frame(r_vector)
marks <- as.data.frame(matrix(0, ncol = 15, nrow = npoints))
datadf <- as.data.frame(data)
for (point in 1:(nrow(datadf)-1)) {
x1 <- datadf[point,1]
y1 <- datadf[point,2]
for (other_point in (point+1):(nrow(datadf))) {
x2 <- datadf[other_point,1]
y2 <- datadf[other_point,2]
for (radius_index in 1:15) {
current_radius <- seq(0.0, 0.14, 0.01)[radius_index]
if ((x1-x2)**2+(y1-y2)**2 <= current_radius**2) {
marks[point,radius_index:15] <- marks[point,radius_index:15] + rep(weights[point, other_point], each=length(radius_index:15))
marks[other_point,radius_index:15] <- marks[other_point,radius_index:15] + rep(weights[other_point, point], each=length(radius_index:15))
break
}
}
}
}
marks(data) <- marks
# assuming that confence intervals formed in the same way as subsets method
for (sim in 1:R) {
n_sum <- 0
k_vals_current <- data.frame(rep(c(0), each=15))
for (i in 1:N) {
xstart <- runif(1,0,1)
ystart <- runif(1,0,1)
xend <- xstart + 1/sqrt(N)
yend <- ystart + 1/sqrt(N)
# using modulus so that points that "wrap around" are next to each other
if (xend <= 1 & yend <= 1) {
subregion <- as.data.frame(subset(data, (xstart <= x & x < xend) & (ystart <= y & y < yend)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
} else if (xend > 1 & yend <= 1) {
subregion <- as.data.frame(subset(data, (xstart <= x | x < xend %% 1) & (ystart <= y & y < yend)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart)))
} else if (xend <= 1 & yend > 1) {
subregion <- as.data.frame(subset(data, (xstart <= x & x < xend) & (ystart <= y | y < yend %% 1)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart)))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
} else {
subregion <- as.data.frame(subset(data, (xstart <= x | x < xend %% 1) & (ystart <= y | y < yend %% 1)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
}
n <- nrow(subregion)
n_sum <- n_sum + n
subregion <- as.ppp(subregion, window)
#print(paste0("marks:",marks(subregion)))
k <- colSums(marks(subregion))
#print(paste0("k:",k))
k_vals_current <- cbind(k_vals_current, as.numeric(k))
}
k_vals <- cbind(k_vals, rowSums(k_vals_current) / (n_sum * (n_sum - 1)))
}
K_est <- as.data.frame(Kest(data, r = r_vector, correction=c("isotropic")))["iso"]
lower_approx <- c()
upper_approx <- c()
for (radius in 1:15) {
sorted_k_vals <- sort(as.numeric(k_vals[radius,-1]))
lower <- sorted_k_vals[round((R+1)*(1-alpha/2), digits=0)]
upper <- sorted_k_vals[round((R+1)*(alpha/2), digits=0)]
lower_approx <- c(lower_approx, 2*K_est[radius,] - lower)
upper_approx <- c(upper_approx, 2*K_est[radius,] - upper)
}
return(cbind(lower_approx, upper_approx))
}
marked4 <- poisson_simulation_marked_point2(10, 250, 4, 0.05)
plot(marked4[-1,], ylim=c(0,1), type="l", lty=3, main="Poisson: marked point")
marked16 <- poisson_simulation_marked_point2(100, 250, 16, 0.05)
lines(marked16[-1,], ylim=c(0,1), type="l", lty=2, main="Poisson: marked point")
source("poisson_simulation_method_1.R")
library(spatstat)
marked_point_method2 <- function(data, N, alpha, R=99) {
npoints <- nrow(as.data.frame(data))
r <- t(as.data.frame(replicate(npoints,seq(0.0, 0.14, 0.01))))
weights <- edge.Ripley(data,pairdist(data))
a <- 1/N
increment <- 1/sqrt(N)
window <- owin(c(0, increment), c(0,increment))
r_vector <- seq(0.0, 0.14, 0.01)
k_vals <- data.frame(r_vector)
marks <- as.data.frame(matrix(0, ncol = 15, nrow = npoints))
datadf <- as.data.frame(data)
for (point in 1:(nrow(datadf)-1)) {
x1 <- datadf[point,1]
y1 <- datadf[point,2]
for (other_point in (point+1):(nrow(datadf))) {
x2 <- datadf[other_point,1]
y2 <- datadf[other_point,2]
for (radius_index in 1:15) {
current_radius <- seq(0.0, 0.14, 0.01)[radius_index]
if ((x1-x2)**2+(y1-y2)**2 <= current_radius**2) {
marks[point,radius_index:15] <- marks[point,radius_index:15] + rep(weights[point, other_point], each=length(radius_index:15))
marks[other_point,radius_index:15] <- marks[other_point,radius_index:15] + rep(weights[other_point, point], each=length(radius_index:15))
break
}
}
}
}
marks(data) <- marks
# assuming that confence intervals formed in the same way as subsets method
for (sim in 1:R) {
n_sum <- 0
k_vals_current <- data.frame(rep(c(0), each=15))
for (i in 1:N) {
xstart <- runif(1,0,1)
ystart <- runif(1,0,1)
xend <- xstart + 1/sqrt(N)
yend <- ystart + 1/sqrt(N)
# using modulus so that points that "wrap around" are next to each other
if (xend <= 1 & yend <= 1) {
subregion <- as.data.frame(subset(data, (xstart <= x & x < xend) & (ystart <= y & y < yend)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
} else if (xend > 1 & yend <= 1) {
subregion <- as.data.frame(subset(data, (xstart <= x | x < xend %% 1) & (ystart <= y & y < yend)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart)))
} else if (xend <= 1 & yend > 1) {
subregion <- as.data.frame(subset(data, (xstart <= x & x < xend) & (ystart <= y | y < yend %% 1)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart)))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
} else {
subregion <- as.data.frame(subset(data, (xstart <= x | x < xend %% 1) & (ystart <= y | y < yend %% 1)))
subregion["x"] <- lapply(subregion["x"], function(x) ((x - xstart) %% 1))
subregion["y"] <- lapply(subregion["y"], function(y) ((y - ystart) %% 1))
}
n <- nrow(subregion)
n_sum <- n_sum + n
subregion <- as.ppp(subregion, window)
#print(paste0("marks:",marks(subregion)))
k <- colSums(marks(subregion))
#print(paste0("k:",k))
k_vals_current <- cbind(k_vals_current, as.numeric(k))
}
k_vals <- cbind(k_vals, rowSums(k_vals_current) / (n_sum * (n_sum - 1)))
}
K_est <- as.data.frame(Kest(data, r = r_vector, correction=c("isotropic")))["iso"]
lower_approx <- c()
upper_approx <- c()
for (radius in 1:15) {
sorted_k_vals <- sort(as.numeric(k_vals[radius,-1]))
lower <- sorted_k_vals[round((R+1)*(1-alpha/2), digits=0)]
upper <- sorted_k_vals[round((R+1)*(alpha/2), digits=0)]
lower_approx <- c(lower_approx, 2*K_est[radius,] - lower)
upper_approx <- c(upper_approx, 2*K_est[radius,] - upper)
}
return(cbind(lower_approx, upper_approx))
}
marked4 <- poisson_simulation_marked_point2(100, 250, 4, 0.05)
plot(marked4[-1,], ylim=c(0,1), type="l", lty=3, main="Poisson: marked point")
marked16 <- poisson_simulation_marked_point2(100, 250, 16, 0.05)
lines(marked16[-1,], ylim=c(0,1), type="l", lty=2, main="Poisson: marked point")
plot(marked4[-1,], ylim=c(0,1), type="l", lty=3, main="Poisson: marked point")
lines(marked16[-1,], ylim=c(0,1), type="l", lty=2, main="Poisson: marked point")
marked64 <- poisson_simulation_marked_point2(100, 250, 64, 0.05)
lines(marked64[-1,], ylim=c(0,1), type="l", lty=1, main="Poisson: marked point")
library(spatstat)
source("method_2_bootstrapping_spatial_point_patterns.R")
source("method_4_bootstrapping_spatial_processes.R")
# uniformly generated sampleson a disc
#nclust <-  function(x0, y0, radius) {
#  n <- rpois(1,10)
#  return(runifdisc(n, radius, centre=c(x0, y0)))
#}
neyman_scott_actual_k <- function(r=seq(0.0, 0.14, 0.01), lambda=25, R=0.1) {
K_actual <- c()
for (radius in 1:length(r)) {
rad <- r[radius]
if (rad > 2*R) {
K_actual <- c(K_actual, pi*rad^2 + 1/lambda)
} else {
z <- rad/(2*R)
k <- pi*(rad^2) + (1/lambda)*(2 + (1/pi)*( ((8*(z^2) - 4)*acos(z)) - 2*asin(z) + 4*z*sqrt((1 - z^2)^3) - 6*z*sqrt(1 - (z^2))))
K_actual <- c(K_actual, k)
}
}
return(K_actual)
}
ns_simulation_approximation <- function(nsim, lambda, nregions, alpha) {
r <- seq(0.0, 0.14, 0.01)
K_actual <- neyman_scott_actual_k()
cover <- rep(c(0),each=15)
coverage <- cbind(r, cover)
for (i in 1:nsim) {
print(paste0("Current simulation:",i))
# generating matérn cluster field
data <- rMatClust(25,0.1,10, win=owin(c(0,1),c(0,1)))
confidences <- approximation_method_2(data, nregions, alpha)
for (j in 1:length(r)) {
if (confidences[j,1] <= K_actual[j] & K_actual[j] <= confidences[j,2]) {
coverage[j,2] <- coverage[j,2] + 1/nsim
}
}
}
return(coverage)
}
ns_simulation_tiling <- function(nsim, lambda, nregions, alpha) {
r <- seq(0.0, 0.14, 0.01)
K_actual <- neyman_scott_actual_k()
cover <- rep(c(0),each=15)
coverage <- cbind(r, cover)
for (i in 1:nsim) {
print(paste0("Current simulation:",i))
# generating matérn cluster field
data <- rMatClust(25,0.1,10, win=owin(c(0,1),c(0,1)))
confidences <- tiling_method(data, nregions, alpha)
for (j in 1:length(r)) {
if (confidences[j,1] <= K_actual[j] & K_actual[j] <= confidences[j,2]) {
coverage[j,2] <- coverage[j,2] + 1/nsim
}
}
}
return(coverage)
}
ns_simulation_subsets5 <- function(nsim, lambda, nregions, alpha) {
r <- seq(0.0, 0.14, 0.01)
K_actual <- neyman_scott_actual_k()
cover <- rep(c(0),each=15)
coverage <- cbind(r, cover)
for (i in 1:nsim) {
print(paste0("Current simulation:",i))
# generating matérn cluster field
data <- rMatClust(25,0.1,10, win=owin(c(0,1),c(0,1)))
confidences <- subsets_method5(data, nregions, alpha)
for (j in 1:length(r)) {
if (confidences[j,1] <= K_actual[j] & K_actual[j] <= confidences[j,2]) {
coverage[j,2] <- coverage[j,2] + 1/nsim
}
}
}
return(coverage)
}
ns_simulation_marked <- function(nsim, lambda, nregions, alpha) {
r <- seq(0.0, 0.14, 0.01)
K_actual <- neyman_scott_actual_k()
cover <- rep(c(0),each=15)
coverage <- cbind(r, cover)
for (i in 1:nsim) {
print(paste0("Current simulation:",i))
# generating matérn cluster field
data <- rMatClust(25,0.1,10, win=owin(c(0,1),c(0,1)))
confidences <- marked_point_method(data, nregions, alpha)
for (j in 1:length(r)) {
if (confidences[j,1] <= K_actual[j] & K_actual[j] <= confidences[j,2]) {
coverage[j,2] <- coverage[j,2] + 1/nsim
}
}
}
return(coverage)
}
ns_simulation_marked2 <- function(nsim, lambda, nregions, alpha) {
r <- seq(0.0, 0.14, 0.01)
K_actual <- neyman_scott_actual_k()
cover <- rep(c(0),each=15)
coverage <- cbind(r, cover)
for (i in 1:nsim) {
print(paste0("Current simulation:",i))
# generating matérn cluster field
data <- rMatClust(25,0.1,10, win=owin(c(0,1),c(0,1)))
confidences <- marked_point_method2(data, nregions, alpha)
for (j in 1:length(r)) {
if (confidences[j,1] <= K_actual[j] & K_actual[j] <= confidences[j,2]) {
coverage[j,2] <- coverage[j,2] + 1/nsim
}
}
}
return(coverage)
}
?edge.Ripley
ns_approx_64
plot(ns_tiling_4[-1,], type="l", lty=3, ylim=c(0,1), main="Clustered: Tiling")
lines(ns_tiling_16[-1,], type="l", lty=2, ylim=c(0.5,1))
lines(ns_tiling_64[-1,], type="l", lty=1, ylim=c(0.5,1))
plot(ns_tiling_4[-1,], type="l", lty=3, ylim=c(0.5,1), main="Clustered: Tiling")
ns_tiling_16 <- ns_simulation_tiling(1000, 250, 16, 0.05)
lines(ns_tiling_16[-1,], type="l", lty=2, ylim=c(0.5,1))
lines(ns_tiling_64[-1,], type="l", lty=1, ylim=c(0.5,1))
ns_tiling_16
plot(ns_approx_4[-1,], type="l", lty=3, ylim=c(0.5,1), main="Clustered: Splitting")
lines(ns_approx_16[-1,], type="l", lty=2, ylim=c(0.5,1))
lines(ns_approx_64[-1,], type="l", lty=1, ylim=c(0.5,1))
plot(ns_subsets_4[-1,], type="l", lty=3, ylim=c(0.5,1), main="Clustered: Subsets")
lines(ns_subsets_16[-1,], type="l", lty=2, ylim=c(0.5,1))
lines(ns_subsets_64[-1,], type="l", lty=1, ylim=c(0.5,1))
plot(ns_approx_4[-1,], type="l", lty=3, ylim=c(0.5,1), main="Clustered: Splitting")
lines(ns_approx_16[-1,], type="l", lty=2, ylim=c(0.5,1))
lines(ns_approx_64[-1,], type="l", lty=1, ylim=c(0.5,1))
ns_simulation_approximation <- function(nsim, lambda, nregions, alpha) {
r <- seq(0.0, 0.14, 0.01)
K_actual <- neyman_scott_actual_k()
cover <- rep(c(0),each=15)
coverage <- cbind(r, cover)
for (i in 1:nsim) {
print(paste0("Current simulation:",i))
# generating matérn cluster field
data <- rMatClust(25,0.1,10, win=owin(c(0,1),c(0,1)))
confidences <- approximation_method_2(data, nregions, alpha)
for (j in 1:length(r)) {
if (confidences[j,1] <= K_actual[j] & K_actual[j] <= confidences[j,2]) {
coverage[j,2] <- coverage[j,2] + 1/nsim
}
}
}
return(coverage)
}
ns_approx_4 <- ns_simulation_approximation(100, 250, 4, 0.05)
plot(ns_approx_4[-1,], type="l", lty=3, ylim=c(0.5,1), main="Clustered: Splitting")
ns_approx_16 <- ns_simulation_approximation(100, 250, 16, 0.05)
lines(ns_approx_16[-1,], type="l", lty=2, ylim=c(0.5,1))
ns_approx_64 <- ns_simulation_approximation(100, 250, 64, 0.05)
lines(ns_approx_64[-1,], type="l", lty=1, ylim=c(0.5,1))
warnings()
ns_approx_16 <- ns_simulation_approximation(100, 250, 16, 0.05)
warnings()
ulation_approximation2(1000,250,4,0.05)
coverage_approximation_4 <- poisson_simulation_approximation2(1000,250,4,0.05)
plot(coverage_approximation_4, ylim = c(0,1), main="Poisson: splitting", type="l", lty=3)
coverage_approximation_16 <- poisson_simulation_approximation2(1000,250,16,0.05)
lines(coverage_approximation_16, ylim = c(0,1), main="Approximation, N=16", type="l", lty=2)
plot(coverage_approximation_4[-1,], ylim = c(0.5,1), main="Poisson: splitting", type="l", lty=3)
lines(coverage_approximation_16[-1,], ylim = c(0.5,1), main="Approximation, N=16", type="l", lty=2)
